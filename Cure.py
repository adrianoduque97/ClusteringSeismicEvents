import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from sklearn.cluster import AgglomerativeClustering as cure
from sklearn.manifold import TSNE
from plotnine import ggplot, geom_point, ggtitle, aes
from sklearn.metrics import accuracy_score
import warnings
import math
import matplotlib.pylab as plt
import sys

warnings.filterwarnings("ignore")    

colors = ['r','g', 'b', 'c', 'm', 'y', 'k', 'grey', 'orange', 'purple']
markers = ['o','^','s','.', ',', 'x', '+', 'v', 'd','>']
acc =[]
def getAcc():
    return acc
def getCentroid(data, indexes):
    x = 0
    y = 0
    for i in range(0, len(data)):
        if i in indexes:
            x += data[i][0]
            y += data[i][1]

    x /= len(indexes)
    y /= len(indexes)
    return x,y

def getClustroid(data, indexes, centroid):
    minDist = sys.maxsize
    clustroid = None
    for i in range(0, len(data)):
        if i in indexes:
            dist = distance(centroid, data[i])
            if dist < minDist:
                minDist = dist
                clustroid = data[i]
    return clustroid
#Method that plot the data generated by t-SNE
def graficar(input_data, predictions, title=1):

    dat = pd.DataFrame()
    dat['x1'] = input_data[:, 0]
    dat['y1'] = input_data[:, 1]

    klus = list(range(title))
    for i, c, m in zip(klus, colors, markers):
        plt.scatter(input_data[predictions == i, 0], input_data[predictions == i, 1],marker=m, c=c, label=i)
    plt.savefig("Clusters"+str(title)+"cureR.png")
    plt.close()

def distance(p0, p1):
    return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)

if __name__ == "__main__":
    input_data = pd.read_csv("features_Modified.csv",delimiter=',', header=None)
    labels = pd.read_csv('labels(1VT-0LP).csv' , header=None)
    print(labels)

    tsne = TSNE(n_components=2, random_state=0)
    newX = tsne.fit_transform(input_data)

    for i in range(2, 11):
        cure_instance = cure(n_clusters=i,linkage="average", affinity="euclidean")
        y=cure_instance.fit_predict(input_data)
        r = cure_instance.labels_
        print(r)
        print("ACC: " + str(accuracy_score(r, labels)))
        acc.append("CURE"+str(i)+" "+str(accuracy_score(r, labels)))

        clustersLen = {}
        for j in range(0, len(input_data)):
            if not r[j] in clustersLen:
                clustersLen[r[j]] = [j]
            else:
                clustersLen[r[j]].append(j)

        centroids = []
        clustroids = []
        for j in range(0, i):
            print("Cluster " + str(j) + ": " + str(len(clustersLen[j])))
            print(clustersLen[j])
            centroide = getCentroid(newX, clustersLen[j])
            centroids.append(centroide)
            clustroide = getClustroid(newX, clustersLen[j], centroide)
            clustroids.append(clustroide)

        graficar(newX, r, i)

        clustersLen = {}
        for j in range(0, len(input_data)):
            if not r[j] in clustersLen:
                clustersLen[r[j]] = 1
            else:
                clustersLen[r[j]] += 1

        print(clustersLen)
        print(82 * "_")

print(acc)
